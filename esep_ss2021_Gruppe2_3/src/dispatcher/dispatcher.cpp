#include <dispatcher/cnnMngmnt/QnxConnection.h>
#include "dispatcher.h"
#include <errno.h>
#include "Event.h"
#include "SyncMsg.h"

namespace dispatcher {

dispatcher::dispatcher(const std::string &name, const std::string &fts2_dispatcher_name) :
        _channel(std::unique_ptr<cnnMngmnt::QnxChannel>(new cnnMngmnt::QnxChannel(name))) {
    _dispatcher_thread = std::thread([this] {this->run();});
    if (fts2_dispatcher_name != "SINGLE") {
        // Connect to other dispatcher
        _fts2_dispatcher_connection = std::unique_ptr<cnnMngmnt::QnxConnection>(
                new cnnMngmnt::QnxConnection(fts2_dispatcher_name));
        std::cout<<"connection established"<<std::endl;
    } else {
        _fts2_dispatcher_connection = std::unique_ptr<cnnMngmnt::QnxConnection>(nullptr);
    }
}

dispatcher::~dispatcher() {
    _is_running = false;
    cnnMngmnt::QnxConnection(_channel->get_chid()).msg_send_pulse(1, _PULSE_CODE_UNBLOCK, 0);
    _dispatcher_thread.join();
}

void dispatcher::run() {
    while (_is_running) {
        cnnMngmnt::header_t header;
        cnnMngmnt::MsgType type = _channel->msg_receive(&header, sizeof(cnnMngmnt::header_t));

        if (type == cnnMngmnt::MsgType::error) {
            //TODO logging or exception
            break;
        }

        if (type == cnnMngmnt::MsgType::puls) { // Pulse was received
            if (header.code == _PULSE_CODE_UNBLOCK) {
                continue;
            }
            handle_event(header);
            continue;
        }

        //else type == sync

        if ((_IO_BASE <= header.type) && (header.type <= _IO_MAX)) {
            // Some QNX IO msg generated by gns was received
            handle_qnx_io_msg(header);
            continue;
        }

        handle_sync_msg(header);
    }
}
void dispatcher::handle_sync_msg(cnnMngmnt::header_t header) {
    if (SyncMsgType::SUBSCRIBE == SyncMsgType(header.type)) { //when is event subscr
        int ret[1] = { 0 };

        EventSubscription subscription;
        _channel->msg_read(&subscription, sizeof(subscription), sizeof(header));
        subscribe(subscription);

        _channel->msg_reply(EOK, ret, sizeof(ret));
        std::cout << "subscribed" << std::endl;
    }
    //maybe other forms of sync communications
}

void dispatcher::subscribe(EventSubscription subscr) {
    if (_chid_conn_map.find(subscr.chid) == _chid_conn_map.end()) { //no connection for this chid yet
        _chid_conn_map[subscr.chid] = std::shared_ptr<cnnMngmnt::QnxConnection>(
                new cnnMngmnt::QnxConnection(subscr.chid));
    }
    _evnt_conn_multimap[static_cast<int>(subscr.type)].insert(_chid_conn_map[subscr.chid]);
}

void dispatcher::handle_event(cnnMngmnt::header_t header) const {
    int evnt_id = header.code;
    int evnt_value = header.value.sival_int;
    if ((evnt_id & 0b01000000) != 0) {
        // mask out transmission bit if message is for other dispatcher
        evnt_id = evnt_id & (~0b01000000);
        if (_fts2_dispatcher_connection.get() != nullptr) {
            // send event to other dispatcher if not in single mode
            _fts2_dispatcher_connection->msg_send_pulse(1, evnt_id, evnt_value);
        }
    }
    std::cout << "dispatcher received following event:" << std::endl;
    std::cout << "id: " << evnt_id << std::endl;
    std::cout << "value: " << evnt_value << std::endl;

    for (auto& connection : _evnt_conn_multimap[evnt_id]) {
        connection->msg_send_pulse(1, evnt_id, evnt_value);
    }
}

void dispatcher::handle_qnx_io_msg(cnnMngmnt::header_t header) const {
    if (header.type == _IO_CONNECT) {
        // QNX IO msg _IO_CONNECT was received; answer with EOK
        std::cout << "Dispatcher received _IO_CONNECT (sync. msg) \n" << std::endl;
        _channel->msg_reply(EOK, nullptr, 0);
        return;
    }
    // Some other QNX IO message was received; reject it
    std::cout << "Dispatcher received unexpected (sync.) msg type = " << header.type << std::endl;
    _channel->msg_reply_error(ENOSYS);
}

} /* namespace dispatcher */
